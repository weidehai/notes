http协议
HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。

通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

IP协议
1.版本号：占四位，就是IP协议的版本，通信双方的IP协议必须要达到一致，IPv4的版本就是4.

2.首部长度：占四位，因为长度为四比特，所以首部长度的最大值为1111，15，又因为首部长度代表的单位长度为32个字（也就是4个字节），所以首部长度的最小值就是0101，当然，也确实如此，大部分的ip头部中首部字节都是0101.也就是5*4=20个字节，如果是最大值15的话，ip首部的最大值就是60个字节，所以记好了，ipv4首部长度的最大值就是60，当然当中我们又能发现，IPv4的首段长度一定是4字节的整数倍，要是不是怎么办呢？别急，后面的填充字段会自动填充补齐到4字节的整数倍的。

3.区分服务：这个没有什么用处，也没有什么好讲的了，只要自动这玩意占八位，一个字节就可以了。

4.总长度：占16位，这个的意思就是ip数据报中首部和数据的总和的长度，因为占16位，所以很好理解，总长度的最大值就是2的16次方减一，65535，这玩意也对应着还有一个很简单的概念，最大传输单元mtu，意味着一个IP数据报的最大长度就只能装下65535个字节，要是传输的长度超过这个怎么办，很简单，分片。
tcp协议
CP将用户数据打包构成报文段，它发送数据时启动一个定时器，另一端收到数据进行确认，对失序的数据重新排序，丢弃重复的数据。TCP提供一种面向连接的可靠的字节流服务，面向连接意味着两个使用TCP的应用（B/S）在彼此交换数据之前，必须先建立一个TCP连接，类似于打电话过程，先拨号振铃，等待对方说喂，然后应答。在一个TCP连接中，只有两方彼此通信。
TCP可靠性来自于：
（1）应用数据被分成TCP最合适的发送数据块
（2）当TCP发送一个段之后，启动一个定时器，等待目的点确认收到报文，如果不能及时收到一个确认，将重发这个报文。
（3）当TCP收到连接端发来的数据，就会推迟几分之一秒发送一个确认。
（4）TCP将保持它首部和数据的检验和，这是一个端对端的检验和，目的在于检测数据在传输过程中是否发生变化。（有错误，就不确认，发送端就会重发）
（5）TCP是以IP报文来传送，IP数据是无序的，TCP收到所有数据后进行排序，再交给应用层
（6）IP数据报会重复，所以TCP会去重
（7）TCP能提供流量控制，TCP连接的每一个地方都有固定的缓冲空间。TCP的接收端只允许另一端发送缓存区能接纳的数据。
（8）TCP对字节流不做任何解释，对字节流的解释由TCP连接的双方应用层解释。
TCP是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接，建立一条连接有以下过程。
1、请求端（客户端）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序列号（ISN），这个SYN为报文段1.
2、服务器发回包含服务器的初始序列号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个字符。
3、客户必须将明确序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）
4、这三个报文段完成连接的建立，这个过程成为三次握手。
1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
3、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
4、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。




tcp/ip协议
TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等

arp协议
一、ARP概述

如果要在TCP/IP协议栈中选择一个"最不安全的协议"，那么我会毫不犹豫把票投给ARP协议。我们经常听到的这些术语，包括"网络扫描"、"内网渗透"、"中间人拦截"、"局域网流控"、"流量欺骗"，基本都跟ARP脱不了干系。大量的安全工具，例如大名鼎鼎的Cain、功能完备的Ettercap、操作傻瓜式的P2P终结者，底层都要基于ARP实现。



听上去这么"逆天"的协议，其实技术原理又简单的难以置信，例如ARP整个完整交互过程仅需要两个包，一问一答即可搞定！但是ARP协议也有它令初学者迷惑的地方，例如由它本身延伸出来的"代理ARP"、"免费ARP"、"翻转ARP"、"逆向ARP"，而这些不同种类的ARP，又应用于不同的场景。好吧，在深入到技术原理之前，作为初学者，我们先记住下面三句话：



①ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。



②在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据封装完整后，再向外发出。所以在局域网的通信中，不仅需要源目IP地址的封装，也需要源目MAC的封装。



③一般情况下，上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。


icmp协议
ICMP协议是一个网络层协议。
一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。
所以我们就需要一种协议来完成这样的功能–ICMP协议。

ICMP协议的功能
ICMP协议的功能主要有：
1. 确认IP包是否成功到达目标地址
2. 通知在发送过程中IP包被丢弃的原因