## 十进制小数转二进制

乘2取整法

0.3

0.3*2 = 0.6   ---- 0

0.6*2 = 1.2   -----1  ---- 0.2

0.2*2  = 0.4  ------0 ---- 0.4

.........

010

乘2取整，只要小数大于0.5，就取到1，小于0.5就取到0，如果不到0.5就一直乘，对应的还原就是2^-n（n表示乘的次数）







## 二进制小数转十进制

$$
0*2^{-1}+1*2^{-2}+0*2^{-3}
$$

n1+n2+n3+n4+n5 = 0.5+0.25+0.125+0.0625+.....

所以浮点数想要完全精确，就必须被0.5整除

假设保存3位数字，0.3-n1-n2-n3就是丢失量





## IEEE754标准

以双精度为例（javascript中的所有数字都是用双精度的浮点数表示的）

符号位  Sign （S）        : 1bit    （b63）
指数部分Exponent （E）   : 11bit   （b62-b52）
尾数部分Mantissa  （M）  : 52bit   （b51-b0）

0.1=》按照乘2取整转成二进制00011001 10011001 10011001 10011001 10011001 10011001 10011010  === 1.1001100110011001100110011001100110011001100110011010 * 10^-4

所有的小数都可以这样表示，所以可以省去最左边的那个1，尾数部分实际上就是53位了

所以乘2取整到算到什么时候呢？

![image-20210607144332316](https://i.loli.net/2021/06/07/mXHItpjWrxvqkTu.png)

所以0.1=符号位0，指数部分2^11+(-4),尾数部分1001100110011001100110011001100110011001100110011010

结果是：0011111110111001100110011001100110011001100110011001100110011010



0.1已ieee754标准存到计算中是已经损失了精度了，再次取出来，通过二进制小数转十进制只能是一个无限接近0.1的数，但是最后取出来还是0.1，这是因为在内部进行了四舍五入才返回的，实际上0.1.toPrecision(21)=0.100000000000000005551,可以看到在内计算的时候确实是进行了某种处理，具体算法不知道，所以在计算机中的浮点数的计算和实际上的理论结果不一定一样



## 浮点数的精度问题

在计算中小数和现实中的小数不一样，显示中小数可以无限长，单位可以无限小，是连续的。而在计算中是做不到这样的，所以计算中小数存储时离散的（只能说在一定的精度内是连续的）







## javascript中数字的最大值

javascript中所有的数值都是以64位的ieee754标准来存储的

最大值：11111111111 

1.1111111111 1111111111 1111111111 1111111111 1111111111 11*e1024





## javascript中的安全整数

JavaScript 能够准确表示的整数范围在-2^53到 2^53之间，超过这个范围，无法精确表示这个值。

![image-20210608172652869](https://i.loli.net/2021/06/08/UZsaC18zp9IofkK.png)

所以2^53+1和2^53冲突了，又因为2^53被截去了一位，精度损失了，所以安全数范围是(-2^53,2^53)

