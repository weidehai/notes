## 垃圾回收

两种策略：1.标记清除

​					2.引用计数

一个函数使用了外部变量，但是还没执行，此时外部变量会被这个函数引用吗？

不会，此时还没有创建执行上下文，不会被引用

### 引用计数

一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象

当声明了一个变量并将一个**引用类型**值赋值该变量时，则这个值的引用次数就是1（原因：当进入函数，浏览器会创建执行上下文，会把函数中定义的所有变量，函数都放到执行上下文的变量对象中，因为函数上下文对象包含了函数中定义的对象，满足一个对象有访问另一个对象的权限的条件，所以这个变量的引用计数+1，对应的离开函数的时候，因为浏览器会销毁执行上下文，这时候引用计数就会-1）

## 循环引用

```javascript
function problem(){     
    var objectA = new Object();
    var objectB = new Object(); 
 
    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA; 
} 
```

进入函数--->创建执行上下文-->创建两个变量objectA，objectB放入执行上下文中（这两个变量引用计数+1）---->执行objectA.someOtherObject = objectB;objectB.anotherObject = objectA; （objectA对象能访问到objectB对象，objectA对象引用计数+1=2，objectB同理）---->函数执行完毕，销毁执行上下文（objectA，objectB这两个变量引用计数-1=1）---->浏览器判断是否需要回收内存，因为引用不为0，不回收，退出函数

注意：执行上下文只是保存了对象的引用（地址），所以执行上下文销毁并不会销毁objectA，objectB的内存，但是执行上下文一销毁，就无法再找到objectA，objectB，所以再执行上下文销毁前需要先判断变量的引用计数，然后销毁，如果发生了循环引用，就不会销毁，退出函数以后无法再找到这两个变量，而这两个变量还被标记为再使用变量，所以浏览器分配内存时，不会分配这两个变量的内存（浏览器认为变量还在使用，实际上应该销毁），造成了内存泄漏（本应该销毁的没销毁，造成内存浪费；内存溢出：内存满足不了应用程序需要的空间）

**在采用了标记清除回收垃圾后，这个循环引用的问题不存在了，但是闭包造成的内存泄露还存在**

## 引用

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它[原型](https://developer.mozilla.org/en-US/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

（a对象能够访问到b对象，那b对象就被a引用了）

## 函数作用域

作用域：这个函数所能影响到的范围

函数作用域是一个对象

## 执行上下文和关联对象

每个上下文中都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文

（上下文其实也是一个对象，由浏览器创建，栈中的每个上下文就构成了上下文链，函数的上下文是函数的local作用域（仅是函数作用域 的一部分，函数的整个作用域应该是由这个栈中所有上下文构成的链））

## 预装载作用域链

chrome中函数有一个属性*[[Scopes]]*，再函数定义的时候，预先解析出函数的作用域链保存到*[[Scopes]]*，当函数被调用的时候就可以复制这个属性来创建作用域链（是再编译时就确定了，不用等到运行时解析，优化js执行速度）

## 闭包

闭包时一个作用域，是函数作用域链上的一个节点

```
let outer = function() {
    let name = 'Jake';
    return function() {
    	return name;
    };
};
```

只要匿名函数function被创建（定义），那他的闭包就会被创建，也就是说如果函数引用了外部的变量，那么这个外部变量就会被闭包引用，然后将这个函数return出去，那么全局上下文就会引用这个函数，这个函数引用闭包，闭包引用外部变量，导致这个变量name无法销毁

### 如何销毁闭包

销毁闭包就要销毁闭包的引用，闭包的应用是函数，函数被return赋值给变量，所以只要将变量置空就可以销毁闭包

```
const fn = function() {
    let num = 0;
    
    return function() {
        return num += 1;
    }
}

fn()() // 1
fn()() // 1
fn()() // 1
```

上面这段代码就是最简单的闭包，如果我们此时在浏览器控制台执行这段代码，那么不管执行多少次，控制台得到的结果都是1，实际上 fn 就被回收掉了

但如果我们这么写

```
const fn = function() {
    let num = 0;
    
    return function() {
        return num += 1;
    }
}

let f1 = fn();

f1(); // 1
f1(); // 2
f1(); // 3

f1 = null;

f1 = fn();

f1(); // 1
f1(); // 2
f1(); // 3
```

此时的 f1 就是闭包的引用，因此就没法被回收掉
然后使 f1 = null 手动解除引用，再重新赋值后就会发现这个时候闭包也被回收掉了